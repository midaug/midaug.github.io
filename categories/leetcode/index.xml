<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>leetCode on MidAug's Blog</title><link>/categories/leetcode/</link><description>Recent content in leetCode on MidAug's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>days0814@gmail.com (MidAug)</managingEditor><webMaster>days0814@gmail.com (MidAug)</webMaster><lastBuildDate>Sat, 17 Mar 2018 14:33:33 +0000</lastBuildDate><sy:updatePeriod>hourly</sy:updatePeriod><atom:link href="/categories/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>leetCode习题(简单难度)-int数值翻转</title><link>/posts/2018031702/</link><pubDate>Sat, 17 Mar 2018 14:33:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Sat, 17 Mar 2018 14:33:33 +0000</atom:modified><guid>/posts/2018031702/</guid><description>题目内容 给定一个范围为32 位 int 的整数，将其颠倒。
例 1:
输入: 123
输出: 321
例 2:
输入: -123
输出: -321
例 3:
输入: 120
输出: 21
注意:
假设我们的环境只能处理 32 位 int 范围内的整数。根据这个假设，如果颠倒后的结果超过这个范围，则返回 0。
解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.mid.test; public class LeetCode001 { public static void main(String[] args) { System.out.println(reverse(-1230)); } private static int reverse(int x) { long tmp = x; // 防止结果溢出 long result = 0; while (tmp !</description><dc:creator>MidAug</dc:creator><category>leetCode</category><category>算法</category><category>java</category><category>leetCode</category></item><item><title>leetCode习题(简单难度)-int数组去重</title><link>/posts/2018031701/</link><pubDate>Sat, 17 Mar 2018 13:33:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Sat, 17 Mar 2018 13:33:33 +0000</atom:modified><guid>/posts/2018031701/</guid><description>题目内容 给定一个有序数组，你需要原地删除其中的重复内容，使每个元素只出现一次,并返回新的长度。
不要另外定义一个数组，您必须通过用 O(1) 额外内存原地修改输入的数组来做到这一点。
示例：
给定数组: nums = [1,1,2],
你的函数应该返回新长度 2, 并且原数组nums的前两个元素必须是1和2
不需要理会新的数组长度后面的元素
解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.mid.test; import java.util.Arrays; public class LeetCode002 { public static void main(String[] args) { int[] nums = { 1, 1, 1, 2 }; int newLength = removeDuplicates(nums); System.</description><dc:creator>MidAug</dc:creator><category>leetCode</category><category>算法</category><category>java</category><category>leetCode</category></item></channel></rss>