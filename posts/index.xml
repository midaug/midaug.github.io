<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>Posts on MidAug's Blog</title><link>/posts/</link><description>Recent content in Posts on MidAug's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>days0814@gmail.com (MidAug)</managingEditor><webMaster>days0814@gmail.com (MidAug)</webMaster><lastBuildDate>Tue, 30 Aug 2022 21:11:33 +0000</lastBuildDate><sy:updatePeriod>hourly</sy:updatePeriod><atom:link href="/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Git删除历史版本，保留当前状态</title><link>/posts/2022083002/</link><pubDate>Tue, 30 Aug 2022 21:11:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Tue, 30 Aug 2022 21:11:33 +0000</atom:modified><guid>/posts/2022083002/</guid><description>前言 有时候，我们误提交了某些隐私文件，使用git rm xxx删除后，其实版本库中是有历史记录的，想要删除这些记录，但是又不想删除仓库，重建来提交。那么就想办法删除历史记录了。
我们当然不能直接删除.git文件夹，这将导致git存储库出现不可预知的问题。
注意！这会删除所有的历史记录，谨慎操作
操作步骤 要删除所有提交历史记录，但将代码保持在当前状态，可以按照以下方式安全地执行此操作：
创建并切换到latest_branch分支 1 git checkout --orphan latest_branch 添加所有文件 1 git add . 提交更改 1 git commit -am &amp;#34;删除历史版本记录，初始化仓库&amp;#34; 删除分支 1 git branch -D master 将当前分支重命名 1 git branch -m master 强制更新存储库 1 git push -f origin master</description><dc:creator>MidAug</dc:creator><category>git</category><category>git</category></item><item><title>Mac中Git忽略.DS_Store文件</title><link>/posts/2022083001/</link><pubDate>Tue, 30 Aug 2022 21:11:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Tue, 30 Aug 2022 21:11:33 +0000</atom:modified><guid>/posts/2022083001/</guid><description>前言 虽然不是第一次使用mac，也不是第一次在mac上使用git，但对mac实际上非常不熟悉。每次git上传时多出来的.DS_Store文件虽然不清楚具体做什么，但看上去并没什么问题。git一般也是自己一个人单机使用，就算换机也一般是直接换，没有遇到过两个同时使用的时候，上传.DS_Store也就默认都上传了。
但这次用两个mac，一个mac提交了修改，第二个mac想要拉下来时居然遇到了.DS_Store文件被修改过需要提交再merge。什么？我没改过内容呀？所以这个.DS_Store是什么鬼？
.DS_Store是Mac OS用来存储这个文件夹的显示属性的，被作为一种通用的有关显示设置的元数据（比如图标位置等设置）为Finder、Spotlight用。所以在不经意间就会修改这个文件。而文件共享时为了隐私关系将.DS_Store文件删除比较好，因为其中有一些信息在不经意间泄露出去。
Git中处理方案 方案一：项目设置.gitignore 仅针对git的处理最naive的想法就是设置.gitignore文件。
.gitignore文件用于忽略文件，官网介绍在这里，规范如下：
所有空行或者以注释符号 ＃ 开头的行都会被 git 忽略，空行可以为了可读性分隔段落，# 表明注释。 第一个 / 会匹配路径的根目录，举个栗子，”/*.html”会匹配”index.html”，而不是”d/index.html”。 通配符 * 匹配任意个任意字符，? 匹配一个任意字符。需要注意的是通配符不会匹配文件路径中的 /，举个栗子，”d/*.html”会匹配”d/index.html”，但不会匹配”d/a/b/c/index.html”。 两个连续的星号 ** 有特殊含义： 以 **/ 开头表示匹配所有的文件夹，例如 **/test.md 匹配所有的test.md文件。 以 /** 结尾表示匹配文件夹内所有内容，例如 a/** 匹配文件夹a中所有内容。 连续星号 ** 前后分别被 / 夹住表示匹配0或者多层文件夹，例如 a/**/b 匹配到 a/b 、a/x/b 、a/x/y/b 等。 前缀 ! 的模式表示如果前面匹配到被忽略，则重新添加回来。如果匹配到的父文件夹还是忽略状态，该文件还是保持忽略状态。如果路径名第一个字符为 ! ，则需要在前面增加 \ 进行转义。 对于一些常用的系统、工程文件的.gitignore文件可以参考这个网站进行设置，这里有很多模板。
针对.DS_Store文件，在git工程文件夹中新建.gitignore文件，在文件中设置：
.gitignore
**/.DS_Store 对于已经提交的内容，希望git能够忽略，但同时并不会删除本地文件，需要在terminal输入以下命令：</description><dc:creator>MidAug</dc:creator><category>git</category><category>git</category></item><item><title>Nginx 内容缓存及常见参数配置</title><link>/posts/2021122101/</link><pubDate>Tue, 21 Dec 2021 18:11:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Tue, 21 Dec 2021 18:11:33 +0000</atom:modified><guid>/posts/2021122101/</guid><description>场景 使用场景:项目的页面需要加载很多数据，也不是经常变化的，不涉及个性化定制，为每次请求去动态生成数据，性能比不上根据请求路由和参数缓存一下结果，使用 Nginx 缓存将大幅度提升请求速度。
基础 只需要配置 proxy_cache_path 和 proxy_cache 就可以开启内容缓存，前者用来设置缓存的路径和配置，后者用来启用缓存。
http {
...
proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;
server {
proxy_cache mycache;
location / {
proxy_pass http://localhost:8000;
}
}
} 对应参数说明:
1.用于缓存的本地磁盘目录是 /path/to/cache/
2.levels 在 /path/to/cache/ 设置了一个两级层次结构的目录。将大量的文件放置在单个目录中会导致文件访问缓慢，所以针对大多数部署，我们推荐使用两级目录层次结构。如果 levels 参数没有配置，则 NGINX 会将所有的文件放到同一个目录中。
3.keys_zone 设置一个共享内存区，该内存区用于存储缓存键和元数据，有些类似计时器的用途。将键的拷贝放入内存可以使 NGINX 在不检索磁盘的情况下快速决定一个请求是 HIT 还是 MISS，这样大大提高了检索速度。一个 1MB 的内存空间可以存储大约 8000 个 key，那么上面配置的 10MB 内存空间可以存储差不多 80000 个key。
4.max_size 设置了缓存的上限（在上面的例子中是 10G）。这是一个可选项；如果不指定具体值，那就是允许缓存不断增长，占用所有可用的磁盘空间。当缓存达到这个上线，处理器便调用 cache manager 来移除最近最少被使用的文件，这样把缓存的空间降低至这个限制之下。</description><dc:creator>MidAug</dc:creator><category>nginx</category><category>nginx</category></item><item><title>深度分析 IT 职业发展路线，做一个透彻的打工人</title><link>/posts/2021111601/</link><pubDate>Tue, 16 Nov 2021 10:33:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Tue, 16 Nov 2021 10:33:33 +0000</atom:modified><guid>/posts/2021111601/</guid><description>一、前言 俗话说，“男怕入错行，女怕嫁错郎”，如果你是互联网/IT 那恭喜你，入对行了，因为：
互联网/IT 行业薪资是第二，仅次于金融行业 薪资排名前列的岗位都是互联网/IT 行业。 好的行业是个好的开始，混的如何，就要看自己的努力了。
二、职业发展路线 “打工人，打工魂”，优秀的打工人需要时刻思考自己的打工路线图（职业发展路径），做一个有规划、有目标、有追求的打工人。
结合上述两张图，程序员发展路线还是比较丰富的，仔细对比上面两幅图，可以发现一条比较专业路线
初级程序员（工程师）&amp;mdash;&amp;gt; 中/高级/资深程序员（工程师）&amp;mdash;&amp;gt; 系统架构师&amp;mdash;&amp;gt; 初级/高级技术经理&amp;mdash;-&amp;gt; 技术（研发）总监&amp;mdash;&amp;gt;CTO
接下来，本文从_薪资、技能、职责、岗位特征_等角度一一总结每个阶段。
三、初级程序员 3.1 基本特征 计算机、软件相关的童鞋毕业后，大部分会应聘程序员岗位（程序猿、程序猿），英文名 coder/programmer，大家常自嘲叫码农的阶段。
这个角色核心职责：把需求或产品实现为用户可用的软件产品，白话就是：敲代码，从各种 Hello world 开始。
此角色为执行级别，因为经验较少，一般需要求助别人，或与别人一起完（ban）成（zhuan）一个任务。大部分公司会安排一个师傅/老手带你。
3.2 职责（示例） 参与需求分析、设计、评审工作； 执行上级主管安排的工作任务，对负责模块进行数据库表设计、接口文档设计与开发、核心功能开发、冒烟测试 d 等； 对自己负责的工作质量进行把关，主动进行技术与业务知识总结； 负责项目的日常开发维护工作等； 对线上产品出现的较为重大的故障进行分析、排查并且解决或协助解决问题，使产品恢复正常使用； 完成上级安排的其他工作； 3.3 任职要求示例（以 Java 为例） JAVA 基础扎实，熟悉 JSP/Servlet、spring 、spring mvc 等； 熟悉 html、css、Jquery、Ajax 、Javascript 等前端技术； 熟悉 SQL 语法 、oracle 数据库； 熟悉 SQL 语法 、oracle 数据库；具有良好的问题分析、解决能力和沟通表达能力，积极主动，具备一定抗压能力； 具有良好的问题分析、解决能力和沟通表达能力，积极主动，具备一定抗压能力； 为人诚恳、诚实、积极、负责； 有 1 年以上经验或优秀应届毕业生； 3.</description><dc:creator>MidAug</dc:creator><category>修炼</category><category>博文收藏</category></item><item><title>Intel MacOs Big Sur 11.4系统Studio 3T破解</title><link>/posts/2021070201/</link><pubDate>Fri, 02 Jul 2021 13:33:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Fri, 02 Jul 2021 13:33:33 +0000</atom:modified><guid>/posts/2021070201/</guid><description>Studio 3T是我用过最好的用的Mongodb客户端，Mac系统未升级到Big Sur前一直使用2019.3.0版本加 data-man-mongodb-ent-2019.3.0.jar使用，直到升级Big Sur后2019.3.0死活打不开了，重新安装，换别的破解版本都不行。目前使用Studio 3T 2020.8.0 加 data-man-mongodb-ent-2019.3.0.jar版本成功在Big Sur上破解运行了，下面分享一下资源和流程
下载地址：Studio-3T-for-mac_x86_11.4.zip
解压获得文件如下：
安装前先用clear.sh清理原来的缓存及文件 安装 Studio-3T-20200800.dmg 版本
安装完后打开软件让其初始化缓存，什么也不干直接退出 打开 应用程序 &amp;gt; 右键“显示包内容” &amp;gt; 打开Contents/Resources/app 目录
找到data-man-mongodb-ent-开头文件删除
将data-man-mongodb-ent-2019.3.0.jar 复制进来替换 执行 sudo spctl &amp;ndash;master-disable //将11.4版本的安全策略重置为允许任何源 执行 sudo chmod -x ~/.3T/updates //移除目录权限防止软件自动更新 最后愉快的去使用吧！</description><dc:creator>MidAug</dc:creator></item><item><title>ubuntu下RabbitMQ安装及集群配置</title><link>/posts/20190723/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Tue, 23 Jul 2019 00:00:00 +0000</atom:modified><guid>/posts/20190723/</guid><description>RabbitMQ简介 以熟悉的电商场景为例，如果商品服务和订单服务是两个不同的微服务，在下单的过程中订单服务需要调用商品服务进行扣库存操作。按照传统的方式，下单过程要等到调用完毕之后才能返回下单成功，如果网络产生波动等原因使得商品服务扣库存延迟或者失败，会带来较差的用户体验，如果在高并发的场景下，这样的处理显然是不合适的，那怎么进行优化呢？这就需要消息队列登场了。
消息队列提供一个异步通信机制，消息的发送者不必一直等待到消息被成功处理才返回，而是立即返回。消息中间件负责处理网络通信，如果网络连接不可用，消息被暂存于队列当中，当网络畅通的时候在将消息转发给相应的应用程序或者服务，当然前提是这些服务订阅了该队列。如果在商品服务和订单服务之间使用消息中间件，既可以提高并发量，又降低服务之间的耦合度。
RabbitMQ就是这样一款我们苦苦追寻的消息队列。RabbitMQ是一个开源的消息代理的队列服务器，用来通过普通协议在完全不同的应用之间共享数据。
RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。Erlang语言在数据交互方面性能优秀，有着和原生Socket一样的延迟，这也是RabbitMQ高性能的原因所在。可谓“人如其名”，RabbitMQ像兔子一样迅速。
RabbitMQ集群模式 普通模式 默认模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。
镜像模式 把需要的队列做成镜像队列，存在与多个节点属于RabbitMQ的HA方案。该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。
ubuntu下安装RabbitMQ集群 1.配置节点hosts 先配置节点hosts，用于集群，再安装RabbitMQ， 不然安装后可能读不到配置的hosts。如果有自建DNS更佳。
1 2 3 4 vim /etc/hosts #在每个节点上编辑/etc/hosts文件写入以下内容 192.168.10.101 node1 192.168.10.102 node2 192.168.10.103 node3 2.rabbitmq-server安装 以ubuntu为例，使用下面快速安装脚本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/sh ## 官方最新版安装脚本 ## Install RabbitMQ signing key curl -fsSL https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc | sudo apt-key add - ## Install apt HTTPS transport sudo apt-get install apt-transport-https ## Add Bintray repositories that provision latest RabbitMQ and Erlang 21.</description><dc:creator>MidAug</dc:creator><category>RabbitMQ</category><category>消息中间件</category><category>消息中间件</category><category>中间件</category><category>消息队列</category><category>RabbitMQ</category></item><item><title>Nginx作为文件下载服务器</title><link>/posts/20190615/</link><pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Sat, 15 Jun 2019 00:00:00 +0000</atom:modified><guid>/posts/20190615/</guid><description>Nginx conf 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 server { listen 80; server_name 10.43.0.0; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.</description><dc:creator>MidAug</dc:creator><category>Nginx</category><category>文件下载服务</category><category>Nginx</category></item><item><title>CSS自定义滚动条(IE和chrome)</title><link>/posts/2018081401/</link><pubDate>Tue, 14 Aug 2018 10:33:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Tue, 14 Aug 2018 10:33:33 +0000</atom:modified><guid>/posts/2018081401/</guid><description>Chrome滚动条 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /*滑道*/ ::-webkit-scrollbar { width: 5px; height: 5px; background-color: #f7f7f7; } ::-webkit-scrollbar-track { box-shadow: inset 0 0 6px #f7f7f7; border-radius: 10px; } /*滑块*/ ::-webkit-scrollbar-thumb { background-color: #222; border-radius: 10px; } ::-webkit-scrollbar-thumb:hover { background-color: #222; } IE滚动条 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &amp;lt;style type=&amp;#34;text/css&amp;#34;&amp;gt; html{ /*三角箭头的颜色*/ scrollbar-arrow-color: #f4ae21; /*立体滚动条的颜色*/ scrollbar-face-color: #333; /*立体滚动条亮边的颜色*/ scrollbar-3dlight-color: #666; /*滚动条空白部分的颜色*/ scrollbar-highlight-color: #666; /*立体滚动条阴影的颜色*/ scrollbar-shadow-color: #999; /*立体滚动条强阴影的颜色*/ scrollbar-darkshadow-color: #666; /*立体滚动条背景颜色*/ scrollbar-track-color: #666; /*滚动条的基本颜色*/ scrollbar-base-color:#f8f8f8; } &amp;lt;/style&amp;gt; 其他滚动条设置 1 2 3 4 5 6 &amp;lt;!</description><dc:creator>MidAug</dc:creator><category>css</category><category>css</category></item><item><title>leetCode习题(简单难度)-int数值翻转</title><link>/posts/2018031702/</link><pubDate>Sat, 17 Mar 2018 14:33:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Sat, 17 Mar 2018 14:33:33 +0000</atom:modified><guid>/posts/2018031702/</guid><description>题目内容 给定一个范围为32 位 int 的整数，将其颠倒。
例 1:
输入: 123
输出: 321
例 2:
输入: -123
输出: -321
例 3:
输入: 120
输出: 21
注意:
假设我们的环境只能处理 32 位 int 范围内的整数。根据这个假设，如果颠倒后的结果超过这个范围，则返回 0。
解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package com.mid.test; public class LeetCode001 { public static void main(String[] args) { System.out.println(reverse(-1230)); } private static int reverse(int x) { long tmp = x; // 防止结果溢出 long result = 0; while (tmp !</description><dc:creator>MidAug</dc:creator><category>leetCode</category><category>算法</category><category>java</category><category>leetCode</category></item><item><title>leetCode习题(简单难度)-int数组去重</title><link>/posts/2018031701/</link><pubDate>Sat, 17 Mar 2018 13:33:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Sat, 17 Mar 2018 13:33:33 +0000</atom:modified><guid>/posts/2018031701/</guid><description>题目内容 给定一个有序数组，你需要原地删除其中的重复内容，使每个元素只出现一次,并返回新的长度。
不要另外定义一个数组，您必须通过用 O(1) 额外内存原地修改输入的数组来做到这一点。
示例：
给定数组: nums = [1,1,2],
你的函数应该返回新长度 2, 并且原数组nums的前两个元素必须是1和2
不需要理会新的数组长度后面的元素
解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package com.mid.test; import java.util.Arrays; public class LeetCode002 { public static void main(String[] args) { int[] nums = { 1, 1, 1, 2 }; int newLength = removeDuplicates(nums); System.</description><dc:creator>MidAug</dc:creator><category>leetCode</category><category>算法</category><category>java</category><category>leetCode</category></item><item><title>java调用phantomjs爬取网页及快照</title><link>/posts/20180129/</link><pubDate>Mon, 29 Jan 2018 21:11:33 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Mon, 29 Jan 2018 21:11:33 +0000</atom:modified><guid>/posts/20180129/</guid><description>前言 前阵子遇到一个需求，需要爬取学信网学历的查询结果进行解析并截图留证，利用java完成了爬取的html解析功能后发现截图较为困难。我偶然发现了 phantomjs，可以由服务端去做类似爬虫的操作来爬取html和保存图片，正好满足上述两个需求。
phantomjs 官方网站: phantomjs.org
phantomjs 是 一个基于 webkit 内核的无头浏览器，没有 UI 界面。它就是一个浏览器，只是内部的点击、翻页等人为相关操作需要程序设计实现。
提供了 javascript API 接口，可以通过 js 直接与 webkit 内核交互，在此之上可以结合 Java 语言等，通过 Java 调用 js 等相关操作，从而解决了以前 c/c++ 才能比较好的基于 webkit 开发优质采集器的限制。
提供了 windows、linux、mac 等不同 OS 的安装使用包，也就是说可以在不同平台上，二次开发采集项目（爬虫）或是自动项目测试等工作。
常用内置对象 1 2 3 4 5 6 // 获得系统操作对象，包括命令行参数、phantomjs系统设置等信息 var system = require(&amp;#39;system&amp;#39;); // 获取操作dom或web网页的对象，通过它可以打开网页、接收网页内容、request、response参数，其为最核心对象。 var page = require(&amp;#39;webpage&amp;#39;); // 获取文件系统对象，通过它可以操作操作系统的文件操作，包括read、write、move、copy、delete等。 var fs = require(&amp;#39;fs&amp;#39;); 常用API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 通过page对象通过url链接打开页面，加载完成后回调 page.</description><dc:creator>MidAug</dc:creator><category>phantomjs</category><category>爬虫</category><category>网页快照</category><category>javascript</category><category>java</category><category>爬虫</category></item><item><title>Cmd Markdown 复制过来的语法测试</title><link>/posts/20171220/</link><pubDate>Wed, 20 Dec 2017 17:11:34 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Wed, 20 Dec 2017 17:11:34 +0000</atom:modified><guid>/posts/20171220/</guid><description>欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：
整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持） $$x = {-b \pm \sqrt{b^2-4ac} \over 2a}.$$
$$\sum_{i=0}^N\int_{a}^{b}g(t,i)\text{d}t$$
除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：
Windows/Mac/Linux 全平台客户端 Windows/Mac/Linux 全平台客户端
请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 新文稿 或者使用快捷键 Ctrl+Alt+N。
什么是 Markdown Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以
1. 制作一份待办事宜 Todo 列表
支持以 PDF 格式导出文稿
改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
新增 Todo 列表功能</description><dc:creator>MidAug</dc:creator><category>test</category><category>测试</category></item><item><title>MongoDB快速同步脚本</title><link>/posts/20171121/</link><pubDate>Tue, 21 Nov 2017 00:00:00 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Tue, 21 Nov 2017 00:00:00 +0000</atom:modified><guid>/posts/20171121/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #!/bin/bash #锁定脚本执行目录 DIR=&amp;#34;$( cd &amp;#34;$( dirname &amp;#34;$0&amp;#34; )&amp;#34; &amp;amp;&amp;amp; pwd )&amp;#34; cd &amp;#34;${DIR}&amp;#34; #指定执行命令 MONGODUMP=mongodump MONGORESTORE=mongorestore #设置tmp或备份目录 BACKUP_DIR=&amp;#34;.</description><dc:creator>MidAug</dc:creator><category>MongoDB</category><category>MongoDB</category><category>数据同步</category><category>数据备份</category></item><item><title>树莓派3安装centos7的无线WIFI模块</title><link>/posts/20170821/</link><pubDate>Mon, 21 Aug 2017 00:00:00 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Mon, 21 Aug 2017 00:00:00 +0000</atom:modified><guid>/posts/20170821/</guid><description>入手raspberry pi3，觉着还是刷个centos系统比较顺手。整理了一下刷centos后WIFI问题解决方式。
驱动安装 1 2 3 4 5 6 7 # 直接执行下面命令即可，如果没有网络就使用u盘拷贝到对应的目录下 curl --location https://github.com/RPi-Distro/firmware-nonfree/raw/54bab3d6a6d43239c71d26464e6e10e5067ffea7/brcm80211/brcm/brcmfmac43430-sdio.bin &amp;gt; /usr/lib/firmware/brcm/brcmfmac43430-sdio.bin curl --location https://github.com/RPi-Distro/firmware-nonfree/raw/54bab3d6a6d43239c71d26464e6e10e5067ffea7/brcm80211/brcm/brcmfmac43430-sdio.txt &amp;gt; /usr/lib/firmware/brcm/brcmfmac43430-sdio.txt # 重启 reboot 查看无线网卡并连接WIFI 1 2 3 4 nmcli d nmcli d wifi　#查看周围的wifi nmcli d wifi connect yourSSID password &amp;#39;yourpassword&amp;#39; #连接wifi SSID就是WIFI名称 nmcli d show wlan0 #查看wlan0的状态 设置静态IP 1 2 3 4 5 #设置网络配置信息vi /etc/sysconfig/network-script/ifcfg-???? #????是wifi的名字 BOOTPROTO=static #静态IP IPADDR=192.168.31.160 #IP地址 GATEWAY=192.</description><dc:creator>MidAug</dc:creator><category>树莓派</category><category>Raspberry Pi</category><category>RPI3</category><category>树莓派</category><category>Raspberry Pi</category></item></channel></rss>