<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title>RabbitMQ on MidAug's Blog</title><link>/tags/rabbitmq/</link><description>Recent content in RabbitMQ on MidAug's Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>days0814@gmail.com (MidAug)</managingEditor><webMaster>days0814@gmail.com (MidAug)</webMaster><lastBuildDate>Tue, 23 Jul 2019 00:00:00 +0000</lastBuildDate><sy:updatePeriod>hourly</sy:updatePeriod><atom:link href="/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml"/><item><title>ubuntu下RabbitMQ安装及集群配置</title><link>/posts/20190723/</link><pubDate>Tue, 23 Jul 2019 00:00:00 +0000</pubDate><author>days0814@gmail.com (MidAug)</author><atom:modified>Tue, 23 Jul 2019 00:00:00 +0000</atom:modified><guid>/posts/20190723/</guid><description>RabbitMQ简介 以熟悉的电商场景为例，如果商品服务和订单服务是两个不同的微服务，在下单的过程中订单服务需要调用商品服务进行扣库存操作。按照传统的方式，下单过程要等到调用完毕之后才能返回下单成功，如果网络产生波动等原因使得商品服务扣库存延迟或者失败，会带来较差的用户体验，如果在高并发的场景下，这样的处理显然是不合适的，那怎么进行优化呢？这就需要消息队列登场了。
消息队列提供一个异步通信机制，消息的发送者不必一直等待到消息被成功处理才返回，而是立即返回。消息中间件负责处理网络通信，如果网络连接不可用，消息被暂存于队列当中，当网络畅通的时候在将消息转发给相应的应用程序或者服务，当然前提是这些服务订阅了该队列。如果在商品服务和订单服务之间使用消息中间件，既可以提高并发量，又降低服务之间的耦合度。
RabbitMQ就是这样一款我们苦苦追寻的消息队列。RabbitMQ是一个开源的消息代理的队列服务器，用来通过普通协议在完全不同的应用之间共享数据。
RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。Erlang语言在数据交互方面性能优秀，有着和原生Socket一样的延迟，这也是RabbitMQ高性能的原因所在。可谓“人如其名”，RabbitMQ像兔子一样迅速。
RabbitMQ集群模式 普通模式 默认模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。
镜像模式 把需要的队列做成镜像队列，存在与多个节点属于RabbitMQ的HA方案。该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。
ubuntu下安装RabbitMQ集群 1.配置节点hosts 先配置节点hosts，用于集群，再安装RabbitMQ， 不然安装后可能读不到配置的hosts。如果有自建DNS更佳。
1 2 3 4 vim /etc/hosts #在每个节点上编辑/etc/hosts文件写入以下内容 192.168.10.101 node1 192.168.10.102 node2 192.168.10.103 node3 2.rabbitmq-server安装 以ubuntu为例，使用下面快速安装脚本
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/sh ## 官方最新版安装脚本 ## Install RabbitMQ signing key curl -fsSL https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc | sudo apt-key add - ## Install apt HTTPS transport sudo apt-get install apt-transport-https ## Add Bintray repositories that provision latest RabbitMQ and Erlang 21.</description><dc:creator>MidAug</dc:creator><category>RabbitMQ</category><category>消息中间件</category><category>消息中间件</category><category>中间件</category><category>消息队列</category><category>RabbitMQ</category></item></channel></rss>