[{"content":"RabbitMQ简介 以熟悉的电商场景为例，如果商品服务和订单服务是两个不同的微服务，在下单的过程中订单服务需要调用商品服务进行扣库存操作。按照传统的方式，下单过程要等到调用完毕之后才能返回下单成功，如果网络产生波动等原因使得商品服务扣库存延迟或者失败，会带来较差的用户体验，如果在高并发的场景下，这样的处理显然是不合适的，那怎么进行优化呢？这就需要消息队列登场了。\n消息队列提供一个异步通信机制，消息的发送者不必一直等待到消息被成功处理才返回，而是立即返回。消息中间件负责处理网络通信，如果网络连接不可用，消息被暂存于队列当中，当网络畅通的时候在将消息转发给相应的应用程序或者服务，当然前提是这些服务订阅了该队列。如果在商品服务和订单服务之间使用消息中间件，既可以提高并发量，又降低服务之间的耦合度。\nRabbitMQ就是这样一款我们苦苦追寻的消息队列。RabbitMQ是一个开源的消息代理的队列服务器，用来通过普通协议在完全不同的应用之间共享数据。\nRabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。Erlang语言在数据交互方面性能优秀，有着和原生Socket一样的延迟，这也是RabbitMQ高性能的原因所在。可谓“人如其名”，RabbitMQ像兔子一样迅速。\nRabbitMQ集群模式 普通模式 默认模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。\n镜像模式 把需要的队列做成镜像队列，存在与多个节点属于RabbitMQ的HA方案。该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。\nubuntu下安装RabbitMQ集群 1.配置节点hosts 先配置节点hosts，用于集群，再安装RabbitMQ， 不然安装后可能读不到配置的hosts。如果有自建DNS更佳。\n1 2 3 4  vim /etc/hosts #在每个节点上编辑/etc/hosts文件写入以下内容 192.168.10.101 node1 192.168.10.102 node2 192.168.10.103 node3   2.rabbitmq-server安装 以ubuntu为例，使用下面快速安装脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #!/bin/sh ## 官方最新版安装脚本 ## Install RabbitMQ signing key curl -fsSL https://github.com/rabbitmq/signing-keys/releases/download/2.0/rabbitmq-release-signing-key.asc | sudo apt-key add - ## Install apt HTTPS transport sudo apt-get install apt-transport-https ## Add Bintray repositories that provision latest RabbitMQ and Erlang 21.x releases sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list \u0026lt;\u0026lt;EOF deb https://dl.bintray.com/rabbitmq-erlang/debian bionic erlang-21.x deb https://dl.bintray.com/rabbitmq/debian bionic main EOF ## Update package indices sudo apt-get update -y ## Install rabbitmq-server and its dependencies sudo apt-get install rabbitmq-server -y --fix-missing   3.在每个节点启用管理插件 1 2 3 4 5  sudo rabbitmq-plugins enable rabbitmq_management sudo rabbitmq-plugins enable rabbitmq_tracing #如果服务已经在启动则先执行 rabbitmqctl stop_app #然后再执行rabbitmq-plugins enable #最后重新start：rabbitmqctl start_app   4.加入集群 因为RabbitMQ集群是基于erlang同步的，所以先配置使各个节点 中 .erlang.cookie文件一致。\n1 2 3 4 5 6 7 8 9  #启动集群前先统一所有节点.erlang.cookie文件，注意文件权限 scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/ #systemctl start rabbitmq-server.service 启动所有节点 #假定node1是主节点， 其他节点依次执行 rabbitmqctl stop_app rabbitmqctl reset rabbitmqctl join_cluster rabbit@node1 #node1的名称与 rabbitmqctl cluster_status 中的信息一致 #rabbitmqctl join_cluster rabbit@node1 --ram #添加为内存节点，默认为磁盘 rabbitmqctl start_app   集群重启顺序（如果没有内存节点请忽略）\n集群重启的顺序是固定的，并且是相反的。 如下所述：\n 启动顺序：磁盘节点 =\u0026gt; 内存节点 关闭顺序：内存节点 =\u0026gt; 磁盘节点  5.创建RabbitMQ用户 设置用户命令, 建议创建好集群后再设置， 不然会被集群配置覆盖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  rabbitmqctl add_user sunday sunday # 创建账号 rabbitmqctl set_user_tags sunday administrator # 设置用户角色 rabbitmqctl set_permissions -p \u0026#34;/\u0026#34; sunday \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; \u0026#34;.*\u0026#34; # 设置用户权限 rabbitmqctl list_users # 查看用户列表 rabbitmqctl change_password username password # 修改用户密码 #其他命令 rabbitmqctl status #查看服务信息 rabbitmqctl cluster_status #查看集群状态 Cluster status of node rabbit@node1 ... [{nodes,[{disc,[rabbit@node1,rabbit@node2,rabbit@node3]}]}, {running_nodes,[rabbit@node3,rabbit@node2,rabbit@node1]}, {cluster_name,\u0026lt;\u0026lt;\u0026#34;rabbit@node1\u0026#34;\u0026gt;\u0026gt;}, {partitions,[]}, {alarms,[{rabbit@node3,[]},{rabbit@node2,[]},{rabbit@node1,[]}]}]   6.命令行开启镜像策略 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #开启所有队列为镜像队列\u0026#34;^\u0026#34;匹配名称为所有， \u0026#34;^ha.\u0026#34;匹配名称为ha开头的 rabbitmqctl set_policy ha-all \u0026#34;^\u0026#34; \u0026#39;{\u0026#34;ha-mode\u0026#34;:\u0026#34;all\u0026#34;}\u0026#39; rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority] -p Vhost： 可选参数，针对指定vhost下的queue进行设置 Name: policy的名称 Pattern: queue的匹配模式(正则表达式) Definition：镜像定义，包括三个部分ha-mode, ha-params, ha-sync-mode ha-mode:指明镜像队列的模式，有效值为 all/exactly/nodes all：表示在集群中所有的节点上进行镜像 exactly：表示在指定个数的节点上进行镜像，节点的个数由ha-params指定 nodes：表示在指定的节点上进行镜像，节点名称通过ha-params指定 ha-params：ha-mode模式需要用到的参数 ha-sync-mode：进行队列中消息的同步方式，有效值为automatic和manual priority：可选参数，policy的优先级   docker-compose快速安装单节点 这里使用的启用mqtt的镜像，无需mqtt也可以使用别的\n集群安装请参考 docker-compose安装rabbitmq集群(主从集群\u0026mdash;》镜像集群)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  version:\u0026#34;3\u0026#34;services:rabbitmq-mqtt:container_name:rabbitmq-mqttenvironment:- RABBITMQ_MQTT_DEFAULT_PASS=admin- RABBITMQ_MQTT_DEFAULT_USER=admin- RABBITMQ_MQTT_VHOST=/- RABBITMQ_DEFAULT_PASS=admin- RABBITMQ_DEFAULT_USER=admin- RABBITMQ_DEFAULT_VHOST=/image:cyrilix/rabbitmq-mqtt:latestvolumes:- ./data:/var/lib/rabbitmqports:- 25672:25672/tcp- 4369:4369/tcp- 5671:5671/tcp- 5672:5672/tcp- 8883:8883/tcp- 15672:15672/tcp- 1883:1883/tcprestart:always  ","description":"","id":0,"section":"posts","tags":["RabbitMQ","消息中间件"],"title":"ubuntu下RabbitMQ安装及集群配置","uri":"/posts/20190723/"},{"content":" Nginx conf 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  server { listen 80; server_name 10.43.0.0; #charset koi8-r; #access_log /var/log/nginx/log/host.access.log main; location / { root /usr/share/nginx/html; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } location /build_results/ { proxy_set_header Host $http_host; root /data/jenkins/; index index.html index.htm; autoindex on; # 开启目录文件列表 autoindex_exact_size off; # 显示出文件的确切大小，单位是bytes autoindex_localtime on; # 显示的文件时间为文件的服务器时间 charset utf-8,gbk; # 避免中文乱码 #add_after_body /autoindex.html; #添加html内容， 此文件应放置在 location / 配置的 root目录下 #add_before_body /autoindex.html; #auth_basic \u0026#34;Restricted\u0026#34;; #启用账号密码限制 #这里是验证时的提示信息 #auth_basic_user_file /etc/nginx/passwd/ecarx; #这里是密码文件 #limit_conn one 8; #并发数 #limit_rate 100k; #单个线程最大下载速度，单位KB/s #allow 192.168.1.0/24; #添加允许访问下载 IP 地址段 #allow 172.17.0.0/16; #deny all; #禁用其他 } }   配置Basic Auth权限认证 我们需要htpassword来创建和生成加密的用户用于基础认证(Basic Authentication)\nubuntu 安装 sudo apt-get install apache2-utils\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  htpasswd 命令参数 -c 创建passwdfile.如果passwdfile 已经存在,那么它会重新写入并删去原有内容. -n 不更新passwordfile，直接显示密码 -m 使用MD5加密（默认） -d 使用CRYPT加密（默认） -p 使用普通文本格式的密码 -s 使用SHA加密 -b 命令行中一并输入用户名和密码而不是根据提示输入密码，可以看见明文，不需要交互 -D 删除指定的用户 sudo htpasswd -c /etc/nginx/passwd Postgres #创建密码文件以及用户名= #/etc/nginx/passwd 文件格式如下: loginuser:password #Nginx配置文件新增内容: location /secret { auth_basic \u0026#34;Please input password\u0026#34;; #这里是验证时的提示信息 auth_basic_user_file /etc/nginx/passwd; # 创建的passwd文件 }   优化显示页面 对日期进行格式化，并添加导航路径\n#add_after_body /autoindex.html; #添加html内容， 此文件应放置在 location / 配置的 root目录下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  \u0026lt;script\u0026gt; var formatDate = function (datetime, format) { if (!isNaN(Date.parse(datetime))) { d = new Date(datetime); pad = function (s) { return s \u0026lt; 10 ? \u0026#39;0\u0026#39; + s : s }; mon = function (m) { return [\u0026#39;Jan\u0026#39;, \u0026#39;Feb\u0026#39;, \u0026#39;Mar\u0026#39;, \u0026#39;Apr\u0026#39;, \u0026#39;May\u0026#39;, \u0026#39;Jun\u0026#39;, \u0026#39;Jul\u0026#39;, \u0026#39;Aug\u0026#39;, \u0026#39;Sep\u0026#39;, \u0026#39;Oct\u0026#39;, \u0026#39;Nov\u0026#39;, \u0026#39;Dec\u0026#39;][m] }; datetime = format .replace(\u0026#39;%Y\u0026#39;, d.getFullYear()) .replace(\u0026#39;%m\u0026#39;, pad(d.getMonth() + 1)) .replace(\u0026#39;%d\u0026#39;, pad(d.getDate())) .replace(\u0026#39;%H\u0026#39;, pad(d.getHours())) .replace(\u0026#39;%M\u0026#39;, pad(d.getMinutes())) .replace(\u0026#39;%S\u0026#39;, pad(d.getSeconds())) .replace(\u0026#39;%b\u0026#39;, mon(d.getMonth())); } return datetime; }; window.onload = function () { var datetime_format = \u0026#39;%Y-%m-%d %H:%M\u0026#39;; setTimeout(function () { var title = document.getElementsByTagName(\u0026#34;h1\u0026#34;)[0]; var lastName; var titlehtml = document.title.replace(/\\/$/, \u0026#39;\u0026#39;).split(\u0026#39;/\u0026#39;).slice(1).reduce(function (acc, v, i, a) { lastName = v; return acc + \u0026#39;\u0026lt;a href=\u0026#34;/\u0026#39; + a.slice(0, i + 1).join(\u0026#39;/\u0026#39;) + \u0026#39;/\u0026#34;\u0026gt;\u0026#39; + v + \u0026#39;\u0026lt;/a\u0026gt;/\u0026#39;; }, \u0026#39;Index of /\u0026#39;); title.innerHTML = titlehtml + \u0026#39;\u0026lt;span style=\u0026#34;margin-left: 100px;\u0026#34;\u0026gt;\u0026#39; + lastName + \u0026#39;\u0026lt;/span\u0026gt;\u0026#39;; }, 1); setTimeout(function () { var pre = document.getElementsByTagName(\u0026#34;pre\u0026#34;)[0]; var bodys = pre.innerHTML.split(\u0026#34;\\n\u0026#34;); var list = []; for (var i in bodys) { var bodyline = bodys[i]; if (m = /\\s*\u0026lt;a href=\u0026#34;(.+?)\u0026#34;\u0026gt;(.+?)\u0026lt;\\/a\u0026gt;\\s+(\\S+)\\s+(\\S+)\\s+(\\S+)\\s*/.exec(bodyline)) { filename = m[1]; datetime = m[3] + \u0026#39; \u0026#39; + m[4]; size = m[5]; list.push(bodyline.replace(datetime, formatDate(datetime, datetime_format))); } else { list.push(bodyline); } } pre.innerHTML = list.join(\u0026#34;\\n\u0026#34;); }, 1); }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; a {text-decoration: none;} a:visited {text-decoration: none;} a:hover {text-decoration: none;} a:active {text-decoration: none;} h1 {font-size: 20px;} \u0026lt;/style\u0026gt;   ","description":"","id":1,"section":"posts","tags":["Nginx","文件下载服务"],"title":"Nginx作为文件下载服务器","uri":"/posts/20190615/"},{"content":"Chrome滚动条 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /*滑道*/ ::-webkit-scrollbar { width: 5px; height: 5px; background-color: #f7f7f7; } ::-webkit-scrollbar-track { box-shadow: inset 0 0 6px #f7f7f7; border-radius: 10px; } /*滑块*/ ::-webkit-scrollbar-thumb { background-color: #222; border-radius: 10px; } ::-webkit-scrollbar-thumb:hover { background-color: #222; }   IE滚动条 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; html{ /*三角箭头的颜色*/ scrollbar-arrow-color: #f4ae21; /*立体滚动条的颜色*/ scrollbar-face-color: #333; /*立体滚动条亮边的颜色*/ scrollbar-3dlight-color: #666; /*滚动条空白部分的颜色*/ scrollbar-highlight-color: #666; /*立体滚动条阴影的颜色*/ scrollbar-shadow-color: #999; /*立体滚动条强阴影的颜色*/ scrollbar-darkshadow-color: #666; /*立体滚动条背景颜色*/ scrollbar-track-color: #666; /*滚动条的基本颜色*/ scrollbar-base-color:#f8f8f8; } \u0026lt;/style\u0026gt;   其他滚动条设置 1 2 3 4 5 6  \u0026lt;!-- 去掉横向滚动条 --\u0026gt; \u0026lt;body style=\u0026#34;overflow:scroll;overflow-x:hidden\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- 去掉竖向滚动条 --\u0026gt; \u0026lt;body style=\u0026#34;overflow:scroll;overflow-y:hidden\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;!-- 两个都去掉 --\u0026gt; \u0026lt;body scroll=\u0026#34;no\u0026#34;\u0026gt; \u0026lt;/body\u0026gt;   说明 css自定义滚动条现仅支持IE和Chrome，火狐可以使用JS设置滚动条\n附上两个github上不错的JS滚动条插件\n https://github.com/noraesae/perfect-scrollbar https://github.com/jnicol/trackpad-scroll-emulator  ","description":"","id":2,"section":"posts","tags":["css"],"title":"CSS自定义滚动条(IE和chrome)","uri":"/posts/2018081401/"},{"content":"题目内容 给定一个范围为32 位 int 的整数，将其颠倒。\n例 1:\n输入: 123\n输出: 321\n例 2:\n输入: -123\n输出: -321\n例 3:\n输入: 120\n输出: 21\n注意:\n假设我们的环境只能处理 32 位 int 范围内的整数。根据这个假设，如果颠倒后的结果超过这个范围，则返回 0。\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package com.mid.test; public class LeetCode001 { public static void main(String[] args) { System.out.println(reverse(-1230)); } private static int reverse(int x) { long tmp = x; // 防止结果溢出 \tlong result = 0; while (tmp != 0) { // 当tmp\u0026lt;10时，tmp / 10才等于0 \tresult = result * 10 + tmp % 10; tmp = tmp / 10; // System.out.println(result + \u0026#34; \u0026#34; + tmp); \t} if (result \u0026lt; Integer.MIN_VALUE || result \u0026gt; Integer.MAX_VALUE) { result = 0; } return (int) result; } }   思路 利用取余的特性，对10取余余数就是最后一位数字，然后将这个余数乘以10加上下一个余数。\n在while里打印就能很清晰的看到过程\n1 2 3 4  0 -123 -3 -12 -32 -1 -321 0   ","description":"","id":3,"section":"posts","tags":["leetCode","算法","java"],"title":"leetCode习题(简单难度)-int数值翻转","uri":"/posts/2018031702/"},{"content":"题目内容 给定一个有序数组，你需要原地删除其中的重复内容，使每个元素只出现一次,并返回新的长度。\n不要另外定义一个数组，您必须通过用 O(1) 额外内存原地修改输入的数组来做到这一点。\n示例：\n给定数组: nums = [1,1,2],\n你的函数应该返回新长度 2, 并且原数组nums的前两个元素必须是1和2\n不需要理会新的数组长度后面的元素\n解法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package com.mid.test; import java.util.Arrays; public class LeetCode002 { public static void main(String[] args) { int[] nums = { 1, 1, 1, 2 }; int newLength = removeDuplicates(nums); System.out.println(newLength); System.out.println(Arrays.toString(Arrays.copyOf(nums, newLength))); } public static int removeDuplicates(int[] nums) { int len = nums.length; if (len \u0026lt; 2) { return len; } int end = 0; //新数组长度 \tfor (int i = 1; i \u0026lt; len; i++) { if (nums[i] != nums[end]) { //不同时将不同的值放置在新数组的下一个位置 \tend++; nums[end] = nums[i]; } } return end + 1; } }   思路 我之前的思路有所差异是将相同的往后移\n新的想法：将不同的往对应顺序上塞\n","description":"","id":4,"section":"posts","tags":["leetCode","算法","java"],"title":"leetCode习题(简单难度)-int数组去重","uri":"/posts/2018031701/"},{"content":"前言 前阵子遇到一个需求，需要爬取学信网学历的查询结果进行解析并截图留证，利用java完成了爬取的html解析功能后发现截图较为困难。我偶然发现了 phantomjs，可以由服务端去做类似爬虫的操作来爬取html和保存图片，正好满足上述两个需求。\nphantomjs 官方网站: phantomjs.org\nphantomjs 是 一个基于 webkit 内核的无头浏览器，没有 UI 界面。它就是一个浏览器，只是内部的点击、翻页等人为相关操作需要程序设计实现。\n提供了 javascript API 接口，可以通过 js 直接与 webkit 内核交互，在此之上可以结合 Java 语言等，通过 Java 调用 js 等相关操作，从而解决了以前 c/c++ 才能比较好的基于 webkit 开发优质采集器的限制。\n提供了 windows、linux、mac 等不同 OS 的安装使用包，也就是说可以在不同平台上，二次开发采集项目（爬虫）或是自动项目测试等工作。\n常用内置对象 1 2 3 4 5 6  // 获得系统操作对象，包括命令行参数、phantomjs系统设置等信息 var system = require(\u0026#39;system\u0026#39;); // 获取操作dom或web网页的对象，通过它可以打开网页、接收网页内容、request、response参数，其为最核心对象。 var page = require(\u0026#39;webpage\u0026#39;); // 获取文件系统对象，通过它可以操作操作系统的文件操作，包括read、write、move、copy、delete等。 var fs = require(\u0026#39;fs\u0026#39;);   常用API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  // 通过page对象通过url链接打开页面，加载完成后回调 page.open(url, function (status) {} // 当page.open调用时，会首先执行该函数，在此可以预置一些参数或函数，用于后边的回调函数中 page.onLoadStarted = function() {} // page的所要加载的资源在加载过程中，失败回调处理 page.onResourceError = function(resourceError) {} // page的所要加载的资源在发起请求时，可以回调该函数 page.onResourceRequested = function(requestData, networkRequest) {} // page的所要加载的资源在加载过程中，每加载一个相关资源，都会在此先做出响应， // 它相当于http头部分，核心回调对象为response，可以获取本次请求的cookies、userAgent等 page.onResourceReceived = function(response) {} // 打印一些输出信息到控制台 page.onConsoleMessage = function (msg) {} // alert也是无法直接弹出的，但可以回调alert的内容 page.onAlert = function(msg) {} // 当page.open时，http请求（不包括所引起的其它的加载资源）出现了异常， // 如404、no route to web site等，都会在此回调显示。 page.onError = function(msg, trace) {} // 当page.open打开的url，或者是在打开过程中进行了跳转，可以在这个函数中回调。 page.onUrlChanged = function(targetUrl) {} // 当page.open的目标URL被真正打开后，会在调用open的回调函数前调用该函数，在此可以进行内部的翻页等操作 page.onLoadFinished = function(status) {} // 在所加载的web page内部执行该函数，像翻页、点击、滑动等，均可在此中执行 page.evaluate(function(){}); // 将当前page的现状渲染成图片，输出到指定的文件中去。 page.render(\u0026#34;\u0026#34;);   调用方式 1  $ /bin/phantomjs [配置文件(js文件)] [参数1] [参数2] [参数3] ...   实现 java使用java.lang.Runtime调用，接收返回结果进行操作\nconfig.js 配置文件内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  var page = require(\u0026#39;webpage\u0026#39;).create(); var system = require(\u0026#39;system\u0026#39;); var ssionid = system.args[1]; var address = system.args[2]; // 请求地址，url var output = system.args[3]; // 输出 var pageWidth = 1366; //初始化游览器宽 var pageHeight = 1080; //初始化游览器高 page.viewportSize = { width: pageWidth, height: pageHeight }; //初始化游览器  // 添加ssionid至cookie phantom.addCookie({ \u0026#39;name\u0026#39; : \u0026#39;JSESSIONID\u0026#39;, \u0026#39;value\u0026#39; : ssionid, \u0026#39;domain\u0026#39; : \u0026#39;job.chsi.com.cn\u0026#39;, \u0026#39;path\u0026#39; : \u0026#39;/\u0026#39; }); //打开地址 page.open(address, function (status) { // 打开完毕  if (status === \u0026#34;success\u0026#34;) { // dom操作  var rect = page.evaluate(function () { var html = document.getElementsByTagName(\u0026#39;html\u0026#39;); if(html \u0026amp;\u0026amp; html.length \u0026gt; 0){ if(html[0].innerHTML.indexOf(\u0026#39;id=\u0026#34;contMain\u0026#34;\u0026#39;) \u0026lt; 0){ return null; } return { offset : html[0].getBoundingClientRect(), innerHTML : html[0].innerHTML }; } return null; }); if(!rect){ console.log(output); page.close(); phantom.exit(); return; } console.log(rect.innerHTML); // 输出html  page.clipRect = { //设置截取区域(此设置为全屏)  top:0, left:0, width:rect.offset.width, height:rect.offset.height }; window.setTimeout(function () { page.render(output); // 输出  page.close(); // 关闭  phantom.exit(); // 退出  }, 200); } });   配置文件总结  output为输出方式， 为输出的绝对路径(例如:\u0026lsquo;c:/123.jpg\u0026rsquo;)， 以后缀决定文件格式. 建议使用pdf格式， pdf格式目前测试来看没有出现问题， 图片则出现过背景颜色丢失的情况 console.log(page.renderBase64(\u0026lsquo;JPEG\u0026rsquo;)) 以Base64的格式输出至控制台 这里是因为同时进行html爬取和截图快照， 所以不使用Base64的方式， 且输出的字符串有长度限制， 建议不要大量console.log()， 否则后面的内容可能会缺失 page.evaluate内可进行dom操作， 这里只取了html， 同理可有规则的针对爬取想要的页面信息 addCookie会返回一个boolean值， 有见到别人的文章判断了这个值才进行后续操作， 但我测试来看是有bug的， 即使成功也返回了false 可以利用dom操作获取元素的位置及宽高对clipRect进行设置， 可达对想要的区域截图的目的， 例如截取某个div中的内容  java封装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  public String phantomjs(String confPath, String url, String ssionId, String outPath) { StringBuilder sb = new StringBuilder(); InputStream is = null; InputStreamReader isr = null; BufferedReader br = null; try { String cmd = \u0026#34;phantomjs \u0026#34; + confPath + \u0026#34; \u0026#34; + ssionId + \u0026#34; \u0026#34; + url + \u0026#34; \u0026#34; + outPath; Process ps = Runtime.getRuntime().exec(cmd); is = ps.getInputStream(); isr = new InputStreamReader(is, \u0026#34;utf-8\u0026#34;); // 注意编码格式  br = new BufferedReader(isr); String tmp; while ((tmp = br.readLine()) != null) { sb.append(tmp); } } catch (IOException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } finally { IOUtils.closeQuietly(br); // 注意关闭流  IOUtils.closeQuietly(isr); IOUtils.closeQuietly(is); } String html = sb.toString(); if (html.contains(filePath)) { return null; } return html; }   java封装总结  我这里直接使用phantomjs是因为设置了环境变量， 否则请使用文件的绝对路径 编码格式尤为重要， 否则将出现html乱码问题  总结 phantomjs的功能非常强大，使用起来也是非常简单的。本文中只是一些简单的使用，更多的请自行查看官方API。\n致谢 这是我第一篇hexo文章，在Bingo phantomjs的文章中得到了大量素材与灵感，以此致谢。\n","description":"","id":5,"section":"posts","tags":["phantomjs","爬虫","网页快照","javascript","java"],"title":"java调用phantomjs爬取网页及快照","uri":"/posts/20180129/"},{"content":"欢迎使用 Cmd Markdown 编辑阅读器 我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，Cmd Markdown 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：\n  整理知识，学习笔记 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 撰写发布学术论文（LaTeX 公式支持）   $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$\n$$\\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$$\n除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：\nWindows/Mac/Linux 全平台客户端 Windows/Mac/Linux 全平台客户端\n 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的  新文稿 或者使用快捷键 Ctrl+Alt+N。\n 什么是 Markdown Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以\n1. 制作一份待办事宜 Todo 列表\n  支持以 PDF 格式导出文稿\n  改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率\n  新增 Todo 列表功能\n  修复 LaTex 公式渲染问题\n  新增 LaTex 公式编号功能\n  Cmd Markdown 开发\n 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能  修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考      七月旅行准备\n 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票    2. 书写一个质能守恒公式 $$E=mc^2$$\n3. 高亮一段代码 1 2 3 4 5 6 7  @requires_authorization class SomeClass: pass if __name__ == \u0026#39;__main__\u0026#39;: # A comment print \u0026#39;hello world\u0026#39;   4. 高效绘制流程图 流程图使用插件:hexo-filter-flowchart 流程图\nst=\u0026gt;start: Start\rop=\u0026gt;operation: Your Operation\rcond=\u0026gt;condition: Yes or No?\re=\u0026gt;end\rst-\u0026gt;op-\u0026gt;cond\rcond(yes)-\u0026gt;e\rcond(no)-\u0026gt;op\r5. 高效绘制序列图 序列图使用插件:hexo-filter-sequence 序列图\nAlice-\u0026gt;Bob: Hello Bob, how are you?\rNote right of Bob: Bob thinks\rBob--\u0026gt;Alice: I am good thanks!\r6. 高效绘制甘特图 甘特图\n不支持甘特图\ntitle 项目开发流程\rsection 项目确定\r需求分析 :a1, 2016-06-22, 3d\r可行性报告 :after a1, 5d\r概念验证 : 5d\rsection 项目实施\r概要设计 :2016-07-05 , 5d\r详细设计 :2016-07-08, 10d\r编码 :2016-07-15, 10d\r测试 :2016-07-22, 5d\rsection 发布验收\r发布: 2d\r验收: 3d\r7. 绘制表格    项目 价格 数量     计算机 $1600 5   手机 $12 12   管线 $1 234    8. 更详细语法说明 想要查看更详细的语法说明，可以参考我们准备的 [Cmd Markdown 简明语法手册][1]，进阶用户可以参考 [Cmd Markdown 高阶语法手册][2] 了解更多高级功能。\n总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。\n什么是 Cmd Markdown 您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。\n1. 实时同步预览 我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！\n2. 编辑工具栏 也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。\n3. 编辑模式 完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右侧的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！\n4. 实时的云端文稿 为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。\n5. 离线模式 在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。\n6. 管理工具栏 为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：\n通过管理工具栏可以：\n 发布：将当前的文稿生成固定链接，在网络上发布，分享\n 新建：开始撰写一篇新的文稿\n 删除：删除当前的文稿\n 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地\n 列表：所有新增和过往的文稿都可以在这里查看、操作\n 模式：切换 普通/Vim/Emacs 编辑模式\n7. 阅读工具栏 通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。\n工具栏上的五个图标依次为：\n 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落\n 视图：互换左边编辑区和右边预览区的位置\n 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！\n 阅读：心无旁骛的阅读模式提供超一流的阅读体验\n 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境\n8. 阅读模式 在 阅读工具栏 点击  或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。\n9. 标签、分类和搜索 在编辑区任意行首位置输入以下格式的文字可以标签当前文档：\n标签： 未分类\n标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：\n10. 文稿发布和分享 在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击  (Ctrl+Alt+P) 发布这份文档给好友吧！\n再一次感谢您花费时间阅读这份欢迎稿，点击  (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！\n","description":"","id":6,"section":"posts","tags":["test"],"title":"Cmd Markdown 复制过来的语法测试","uri":"/posts/20171220/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  #!/bin/bash #锁定脚本执行目录 DIR=\u0026#34;$( cd \u0026#34;$( dirname \u0026#34;$0\u0026#34; )\u0026#34; \u0026amp;\u0026amp; pwd )\u0026#34; cd \u0026#34;${DIR}\u0026#34; #指定执行命令 MONGODUMP=mongodump MONGORESTORE=mongorestore #设置tmp或备份目录 BACKUP_DIR=\u0026#34;./sync/backup\u0026#34; NOW=`date +\u0026#34;%Y-%m-%d-%H%M\u0026#34;` #源数据库 DB_SRC_HOST=\u0026#34;host:port\u0026#34; DB_SRC_USER=user DB_SRC_PASSWD=passwd DB_SRC_NAME=database #对象数据库 DB_DES_HOST=\u0026#34;host:port\u0026#34; DB_DES_USER=user DB_DES_PASSWD=passwd DB_DES_NAME=database #指定需要同步的表名称 COLLECTIONS=\u0026#34; table1 table2 \u0026#34; ##COLLECTIONS=\u0026#34;\u0026#34; 为同步database下所有的表 #创建目录 BACKUP_PATH=$BACKUP_DIR/$DB_SRC_NAME/$NOW mkdir -p $BACKUP_PATH #do backup if [ ! -n \u0026#34;$COLLECTIONS\u0026#34; ]; then $MONGODUMP -h $DB_SRC_HOST -d $DB_SRC_NAME -u $DB_SRC_USER -p $DB_SRC_PASSWD -o $BACKUP_PATH else for c in $COLLECTIONS do $MONGODUMP -h $DB_SRC_HOST -d $DB_SRC_NAME -u $DB_SRC_USER -p $DB_SRC_PASSWD -o $BACKUP_PATH -c $c done fi #do override to the dest database. echo \u0026#34;$MONGORESTORE-d $DB_DES_NAME-h $DB_DES_HOST-u $DB_DES_USER-p $DB_DES_PASSWD--drop $BACKUP_PATH/$DB_SRC_NAME\u0026#34; $MONGORESTORE -d $DB_DES_NAME -h $DB_DES_HOST -u $DB_DES_USER -p $DB_DES_PASSWD --drop $BACKUP_PATH/$DB_SRC_NAME #注释删除即为备份 rm -rf $BACKUP_PATH   ","description":"","id":7,"section":"posts","tags":["MongoDB"],"title":"MongoDB快速同步脚本","uri":"/posts/20171121/"},{"content":"入手raspberry pi3，觉着还是刷个centos系统比较顺手。整理了一下刷centos后WIFI问题解决方式。\n驱动安装 1 2 3 4 5 6 7  # 直接执行下面命令即可，如果没有网络就使用u盘拷贝到对应的目录下 curl --location https://github.com/RPi-Distro/firmware-nonfree/raw/54bab3d6a6d43239c71d26464e6e10e5067ffea7/brcm80211/brcm/brcmfmac43430-sdio.bin \u0026gt; /usr/lib/firmware/brcm/brcmfmac43430-sdio.bin curl --location https://github.com/RPi-Distro/firmware-nonfree/raw/54bab3d6a6d43239c71d26464e6e10e5067ffea7/brcm80211/brcm/brcmfmac43430-sdio.txt \u0026gt; /usr/lib/firmware/brcm/brcmfmac43430-sdio.txt # 重启 reboot   查看无线网卡并连接WIFI 1 2 3 4  nmcli d nmcli d wifi　#查看周围的wifi nmcli d wifi connect yourSSID password \u0026#39;yourpassword\u0026#39; #连接wifi SSID就是WIFI名称 nmcli d show wlan0 #查看wlan0的状态   设置静态IP 1 2 3 4 5  #设置网络配置信息vi /etc/sysconfig/network-script/ifcfg-???? #????是wifi的名字 BOOTPROTO=static #静态IP IPADDR=192.168.31.160 #IP地址 GATEWAY=192.168.31.1 #默认网关 NETMASK=255.255.255.0 #子网掩码   修改DNS 1 2 3 4  # vi /etc/resolv.conf #修改以下内容 nameserver 8.8.8.8 #google域名服务器 nameserver 8.8.4.4 #google域名服务器 223.5.5.5 阿里dns nameserver 114.114.114.114   ","description":"","id":8,"section":"posts","tags":["树莓派","Raspberry Pi","RPI3"],"title":"树莓派3安装centos7的无线WIFI模块","uri":"/posts/20170821/"},{"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  { name: \u0026#34;Midaug\u0026#34;, birthday: \u0026#34;1991-08\u0026#34;, gender: \u0026#34;男\u0026#34;, address: \u0026#34;魔都 / 上海\u0026#34;, education: \u0026#34;本科 / 湖南涉外经济学院\u0026#34;, major: \u0026#34;企业财务管理\u0026#34;, Github: \u0026#34;https://github.com/midaug\u0026#34;, skills: [ \u0026#34;Java\u0026#34;, \u0026#34;Spring\u0026#34;, \u0026#34;J2EE\u0026#34;, \u0026#34;Python\u0026#34;, \u0026#34;MVC\u0026#34; , \u0026#34;Git\u0026#34;, \u0026#34;Svn\u0026#34;, \u0026#34;Maven\u0026#34;, \u0026#34;JavaScript\u0026#34;, \u0026#34;Bootstrap\u0026#34;, \u0026#34;AngularJS\u0026#34;, \u0026#34;JQuery\u0026#34;, \u0026#34;HTML\u0026#34;, \u0026#34;CSS\u0026#34;, \u0026#34;PhantomJS\u0026#34;, \u0026#34;MongoDB\u0026#34;, \u0026#34;MySQL\u0026#34;, \u0026#34;Oracle\u0026#34;, \u0026#34;Linux\u0026#34;, \u0026#34;Nginx\u0026#34;, \u0026#34;Shell\u0026#34;, \u0026#34;NodeJS\u0026#34;, \u0026#34;Tomcat\u0026#34;, \u0026#34;baidu ocr\u0026#34;, \u0026#34;alipay open\u0026#34;, \u0026#34;wechat pay\u0026#34;, \u0026#34;sms\u0026#34; ], blog: \u0026#34;http://blog.midaug.win\u0026#34;, Email: \u0026#34;days0814@gmail.com\u0026#34;, description: [\u0026#34;一个自学成才的程序猿\u0026#34;] }   ","description":"","id":9,"section":"","tags":null,"title":"About","uri":"/about/"}]